#include <iostream>
#include <charconv>
#include <iomanip>
#include <iostream>
#include <string_view>
#include <system_error>
#include <chrono>
#include <fstream>
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h> //This is an sample library not included with stock SDL2. https://www.libsdl.org/projects/SDL_ttf/release-1.2.html
#include "math_utils.h"

class Framework{
    public:
        // Contructor which initialize the parameters.
        Framework(int height_, int width_): height(height_), width(width_)
        {
            SDL_Init(SDL_INIT_VIDEO);       // Initializing SDL as Video
            SDL_CreateWindowAndRenderer(width, height, 0, &window, &renderer);
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);      // setting draw color
            SDL_RenderClear(renderer);      // Clear the newly created window
            SDL_RenderPresent(renderer);    // Reflects the changes done in the
            //  window.
            pix_unit = gcd(width,height);
        }

        // Destructor
        ~Framework()
        {
            SDL_DestroyRenderer(renderer);
            SDL_DestroyWindow(window);
            if (circles.size() != 0)
            {
                for(int i = 0; i < circles.size();++i)
                    delete circles[i];
            }
            SDL_Quit();
        }

        void create_circle(int x_c,int y_c, int rad_,int r,int g, int b)
        {
            if (circles.size() == 0)
                circles.push_back(new Circle_SDL(width/2,height/2,rad_,width,height,pix_unit));
            else
                circles.push_back(new Circle_SDL(x_c,y_c,rad_,width/2,height/2,pix_unit));

            colors.push_back(r); colors.push_back(g); colors.push_back(b);


        }

        SDL_Renderer* render_obj() {return renderer;}
        SDL_Window* window_obj() {return window;}
        const std::vector<Circle_SDL*>& circle_vec() {return circles;}
        std::vector<Circle_SDL*>& mut_circle_vec() {return circles;}
        double center_distance_square(int c1, int c2) {return std::pow(circles[c1]->cx_coord-circles[c2]->cx_coord,2) + std::pow(circles[c1]->cy_coord-circles[c2]->cy_coord,2);}
        double center_distance(int c1,int c2) {return std::sqrt(center_distance_square(c1,c2));}
        size_t size() {return circles.size();}
        bool circle_collision(int c1, int c2)
        {
            double totalradius_square = std::pow(circles[c1]->radius_d+circles[c2]->radius_d,2);
            if (center_distance_square(c1,c2) < totalradius_square)
                return true;
            else
                return false;
        }


        void draw_circle(int i)
        {
            // Setting the color to be RED with 100% opaque (0% trasparent).
            SDL_SetRenderDrawColor(renderer,colors[3*i],colors[3*i+1],colors[3*i+2], 255);

            int point_x = 0;
            int point_y = circles[i]->radius_;
            int decision = 1 - circles[i]->radius_;

            while (point_y >= point_x)
            {
                // Symmetric points
                SDL_RenderDrawPoint(renderer, circles[i]->center_x + point_x, circles[i]->center_y + point_y);
                SDL_RenderDrawPoint(renderer, circles[i]->center_x + point_y, circles[i]->center_y + point_x);
                SDL_RenderDrawPoint(renderer, circles[i]->center_x - point_x, circles[i]->center_y + point_y);
                SDL_RenderDrawPoint(renderer, circles[i]->center_x - point_y, circles[i]->center_y + point_x);
                SDL_RenderDrawPoint(renderer, circles[i]->center_x + point_x, circles[i]->center_y - point_y);
                SDL_RenderDrawPoint(renderer, circles[i]->center_x + point_y, circles[i]->center_y - point_x);
                SDL_RenderDrawPoint(renderer, circles[i]->center_x - point_x, circles[i]->center_y - point_y);
                SDL_RenderDrawPoint(renderer, circles[i]->center_x - point_y, circles[i]->center_y - point_x);

                point_x++;

                if (decision < 0)
                {
                    decision += 2 * point_x + 1;
                }
                else
                {
                    point_y--;
                    decision += 2 * (point_x - point_y) + 1;
                }
            }
            SDL_RenderPresent(renderer);
        }

        double force_mag(int c1,int c2)
        {
            if (!circle_collision(c1,c2))
                return 0.0;
            else
                return 2.4525*center_distance(c1,c2);
        }

        Eigen::RowVectorXd force_direction(int c1,int c2)
        {
            Eigen::RowVectorXd normal(2);
            if(!circle_collision(c1,c2))
               normal << 0,0;

            else
            {
                double normal_mag = center_distance(c1,c2);
                normal << (circles[c2]->cx_coord-circles[c1]->cx_coord)/normal_mag,(circles[c2]->cy_coord-circles[c1]->cy_coord)/normal_mag;
            }
            return normal;
        }

        void move(int ci,int x_c,int y_c) {circles[ci]->move(x_c,y_c,width,height,pix_unit);}
        void clear_screen()
        {
             SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
             SDL_RenderClear(renderer);
        }

    private:

        int height;     // Height of the window
        int width;      // Width of the window
        int pix_unit;   //Number of pixels in one unit of grid space

        std::vector<Circle_SDL*> circles;
        std::vector<int> colors;
        SDL_Renderer *renderer = NULL;      // Pointer for the renderer
        SDL_Window *window = NULL;      // Pointer for the window
};


int main(int argc, char * argv[])
{
    const int64_t desired_fps = 240;
    int64_t last_ticks = SDL_GetTicks64();


    // Creating the object by passing Height and Width value.
    Framework fw(1080, 1920);

    // Calling the function that draws circle.
    //fw.draw_circle(960,540,300);
    fw.create_circle(0,0,300,0,0,255);
    int x,y;
    int buttons = SDL_GetMouseState(&x,&y);
    fw.create_circle(x,y,10,255,0,0);
    fw.draw_circle(0);
    double totalradius_square = std::pow(fw.circle_vec()[0]->radius_d+fw.circle_vec()[1]->radius_d,2);
    std::fstream position,force;
    position.open("../data/position.csv",std::fstream::out|std::fstream::trunc);
    force.open("../data/force.csv",std::fstream::out|std::fstream::trunc);


    position << "Time(s),X,Y," << std::endl;
    force << "Time(s),Force_mag (N),Force_dir_x,Force_dir_y" << std::endl;
    std::chrono::time_point<std::chrono::steady_clock> start, end;

    SDL_Event event;    // Event variable
    // Below while loop checks if the window has terminated using close in the
    //  corner.
    int mouse_x,mouse_y;
    uint64_t colnum =0;                         \
    double force_mag;
    Eigen::RowVectorXd force_dir(2);
    start = std::chrono::steady_clock::now();

    while(event.type != SDL_QUIT)
    {
        if (SDL_GetTicks64() - last_ticks < 1000/desired_fps) {
            continue;
        }

        last_ticks = SDL_GetTicks64();

        SDL_PollEvent(&event);  // Catching the poll event.
        if(event.type == SDL_MOUSEMOTION)
        {
             mouse_x = event.motion.x;
             mouse_y = event.motion.y;
             fw.move(1,mouse_x,mouse_y);
             double sqr_dist = fw.center_distance_square(0,1);
            if (fw.circle_collision(0,1))
            {
                force_mag = fw.force_mag(0,1);
                force_dir = fw.force_direction(0,1);
                //std::cout << "Force Magnitude: " <<  fw.force_mag(0,1) << " N" << std::endl;
               //std::cout << "Force Direction: [" <<  fw.force_direction(0,1) << "]" << std::endl;

                if (sqr_dist > totalradius_square - 0.1)
                {
                    fw.clear_screen();
                    for(int i = 0; i < fw.size();++i) fw.draw_circle(i);
                }

                ++colnum;
            }

        }
        end = std::chrono::steady_clock::now();
        std::chrono::duration<double> elapsed_seconds = end - start;
        position << elapsed_seconds.count() << "," << fw.circle_vec()[1]->cx_coord << "," << fw.circle_vec()[1]->cy_coord << "," << std::endl;
        force << elapsed_seconds.count() << "," << force_mag << "," << force_dir(0)  << "," << force_dir(1)  << "," << std::endl;
    }
    force.close();
    position.close();
    return 0;
}
/*
            // Drawing circle
            for(int x= circles[i]->center_x-circles[i]->radius_; x<=circles[i]->center_x+circles[i]->radius_; ++x)
            {
                for(int y=circles[i]->center_y-circles[i]->radius_; y<=circles[i]->center_y+circles[i]->radius_; ++y)
                {
                    if((std::pow(circles[i]->center_y-y,2)+std::pow(circles[i]->center_x-x,2)) <= std::pow(circles[i]->radius_,2))
                        SDL_RenderDrawPoint(renderer, x, y);

                }
            }

            // Show the change on the screen
                    BeginDrawing();
            ClearBackground(RAYWHITE);
            DrawText("I want to fuck Tais tenderly and with passionate virile gusto!", 100, 200, 20, LIGHTGRAY);
            DrawText("Nerdy Brazillian chicks are hot (and cute) as fuck!!!", 100, 220, 20, LIGHTGRAY);
         EndDrawing();
*/
